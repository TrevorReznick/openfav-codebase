Flusso di esecuzione
Theme layout
La pagina Astro src/pages/build/[...component].astro calcola componentPath a partire dall’URL (kebab → PascalCase mantenendo le cartelle base).
Esempio: /build/TestTracker → componentPath = "dashboard/TestTracker" se viene individuato per nome, oppure come già mappato dalla logica di risoluzione.
App shell con provider
AppClient
 (
src/react/AppClient.tsx
) incapsula provider globali:
React Query (QueryClientProvider)
Tema (
ThemeProvider
) con fix SSR safe
Navigazione (
NavigationProvider
)
Toaster (sonner)
Se riceve un target (via componentPath/componentName o useQueryString), delega a DynamicWrapper.
Caricamento dinamico
DynamicWrapper (
src/react/wrappers/dynamicWrapper.tsx
) risolve e carica il componente:
Usa getDynamicComponent (src/react/lib/autoComponentLoader) che interroga il registro Vite (import.meta.glob) dei componenti sotto src/react/components/**.
Supporta vari modi di risoluzione:
Nome univoco del file componente: TestTracker → trova .../dashboard/TestTracker.tsx (come vedi nei log, “✅ Unique name match”).
Percorso esplicito: dashboard/TestTracker, examples/TestComponent, ecc.
Crea un lazy() attorno al loader() dal config e lo rende in Suspense, con fallback (LoadFallback) ed ErrorBoundary.
I log che hai visto arrivano da DynamicWrapper con debug: true:
“Starting to load component: …”
“Successfully got component config”
“Module exports: [default]” ecc.
Perché non hai errori
Il componente richiesto (TestTracker) è stato trovato dal resolver, caricato correttamente via lazy() e montato senza errori. Ecco perché:
Risoluzione: “Unique name match” ha mappato “TestTracker” a src/react/components/dashboard/TestTracker.tsx.
Lazy load OK: modulo caricato, export default presente, Suspense risolto.
Provider e SSR: 
ThemeProvider
 è SSR-safe (niente più localStorage lato server), quindi nessuna eccezione in server-rendering.
Come usarlo (varianti)
Route build
/build/home, /build/dashboard/TestTracker, /build/examples/test-component
Playground con query string
/playground?component=home
/playground?path=dashboard/TestTracker
/playground#examples/TestComponent
In playground/index.astro: <AppClient client:load useQueryString={true} />
Passare props al componente dinamico
AppClient
 accetta wrapperProps che vengono passati al componente caricato:
<AppClient client:load componentPath="examples/TestComponent" wrapperProps={{ foo: 'bar' }} />
Silenziare i log di debug
Imposta wrapperDebug={false} in 
AppClient
:
<AppClient client:load componentPath="..." wrapperDebug={false} />
Componenti e file chiave
src/pages/build/[...component].astro → calcola componentPath e renderizza 
AppClient
.
src/react/AppClient.tsx
 → shell con provider e preferenza per DynamicWrapper.
src/react/wrappers/dynamicWrapper.tsx
 → lazy load, Suspense + ErrorBoundary, log di debug.
src/react/lib/autoComponentLoader.ts → risoluzione via import.meta.glob.